gRPC的拦截器发生在RPC执行前后, 执行自定义的逻辑, 它常用于认证, 授权, 日志, 链路, 监控, 超时控制, 重试等

## 客户端拦截器

### 场景
1. 身份认证: 携带Token, API等身份信息发送请求
2. 监控客户端应用的性能和健康状况: 上报请求的耗时(RPC方法的延迟和请求计数),目标方法,是否成功
3. 重试: 当调用失败（如遇到网络错误 `Unavailable` 或服务器过载 `ResourceExhausted`）时，根据策略自动重试。
## 服务端拦截器
### 场景
1. 认证和授权: 校验客户端传送的身份是否合法, 使用拥有对应的权限
2. 速率限制和熔断: 保护服务端不过载。限制单个客户端或全局的请求频率，或在系统压力大时直接拒绝请求。
3. 指标: 记录请求的来源、处理方法、耗时和结果，用于监控服务端的性能和排查问题。(记录每个请求的客户端 IP、方法名和响应时间，并统计 5xx 错误的数量。)
4. 链路追踪: 从入站请求的元数据中提取分布式追踪的上下文（如 TraceID、SpanID），并创建一个新的 Span 来记录服务端的处理过程。(集成 Jaeger 或 Zipkin，为每个请求创建 Span，并将上下文传递给业务逻辑，以便记录更详细的日志。)
## 场景对比

|场景|客户端拦截器|服务端拦截器|
|---|---|---|
|**认证**|**添加**凭据（如设置 Token）|**验证**凭据（如校验 Token）|
|**弹性**|**实现**重试、超时、负载均衡|**感知**被限流、被熔断|
|**可观测性**|记录**我调用别人**的延迟和状态|记录**别人调用我**的延迟和状态|
|**控制权**|控制**是否**、**何时**以及**如何**发出请求|控制**是否接收**以及**如何处理**接收到的请求|

预处理(RPC最先进入到该层): 对传入的参数进行校验,
调用中: 
调用后: